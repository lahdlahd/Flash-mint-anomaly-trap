// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/// @title FlashMintSpikeTrap
/// @notice Detects abnormal ERC20 totalSupply spikes using Drosera's
///         stateless, window-based execution model
/// @dev Fully Drosera-compatible (stateless + deterministic)

interface IERC20 {
    function totalSupply() external view returns (uint256);
}

/// @dev Required Drosera trap interface
interface ITrap {
    function collect() external view returns (bytes memory);
    function shouldRespond(
        bytes[] calldata data
    ) external pure returns (bool, bytes memory);
}

contract FlashMintSpikeTrap is ITrap {
    /*//////////////////////////////////////////////////////////////
                                CONSTANTS
    //////////////////////////////////////////////////////////////*/

    /// @dev Token being monitored (must be hardcoded for Drosera)
    address internal constant TOKEN =
        0x0000000000000000000000000000000000000000;

    /// @dev Percentage spike required to trigger responder
    /// e.g. 10 = 10%
    uint256 internal constant SPIKE_THRESHOLD_PERCENT = 10;

    /*//////////////////////////////////////////////////////////////
                                COLLECT
    //////////////////////////////////////////////////////////////*/

    /**
     * @notice Collects the current totalSupply snapshot
     * @dev MUST be view-only and stateless for Drosera
     */
    function collect() external view returns (bytes memory) {
        uint256 supply = IERC20(TOKEN).totalSupply();
        return abi.encode(supply);
    }

    /*//////////////////////////////////////////////////////////////
                            SHOULD RESPOND
    //////////////////////////////////////////////////////////////*/

    /**
     * @notice Determines whether a flash mint spike occurred
     * @param data Encoded collect() outputs (newest â†’ oldest)
     */
    function shouldRespond(
        bytes[] calldata data
    ) external pure returns (bool, bytes memory) {
        // Need at least two samples for comparison
        if (data.length < 2) {
            return (false, "");
        }

        uint256 latestSupply = abi.decode(data[0], (uint256));
        uint256 previousSupply = abi.decode(data[1], (uint256));

        if (previousSupply == 0) {
            return (false, "");
        }

        // Calculate absolute delta
        uint256 delta = latestSupply > previousSupply
            ? latestSupply - previousSupply
            : previousSupply - latestSupply;

        uint256 spikePercent = (delta * 100) / previousSupply;

        if (spikePercent >= SPIKE_THRESHOLD_PERCENT) {
            /**
             * Payload sent to responder:
             * - latestSupply
             * - previousSupply
             * - spikePercent
             */
            return (
                true,
                abi.encode(
                    latestSupply,
                    previousSupply,
                    spikePercent
                )
            );
        }

        return (false, "");
    }
}
